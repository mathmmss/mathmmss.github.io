<!DOCTYPE html>
<html lang="pt">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">
    <link rel="shortcut icon" href="../../docs-assets/ico/favicon.png">

    <title>Matheus - PDI</title>

    <!-- Bootstrap core CSS -->
    <link href="assets/css/bootstrap.css" rel="stylesheet">


    <!-- Custom styles for this template -->
    <link href="assets/css/main.css" rel="stylesheet">

    <script src="https://code.jquery.com/jquery-1.10.2.min.js"></script>

    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
    <![endif]-->
  </head>

  <body>

    <!-- Static navbar -->
    <div class="navbar navbar-inverse navbar-static-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">HOME</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="u1.html">Unidade 1</a></li>
            <li><a href="u2.html">Unidade 2</a></li>
            <li><a href="u3.html">Unidade 3</a></li>
            <li><a href="down.html">Downloads</a></li>
          </ul>
        </div><!--/.nav-collapse -->
      </div>
    </div>

	
	<!-- +++++ Post +++++ -->
	<div id="white">
	    <div class="container">
			<div class="row">
				<div class="col-lg-8 col-lg-offset-2">
					<p><img src="assets/img/user.png" width="50px" height="50px"> <ba>Matheus Vinícius</ba></p>
					<h4>Exercício 3.2 - Negativo</h4>
					<br>
					<p><img class="img-responsive" src="assets/img/img2.png" alt=""></p>
					<br>
					<p>Para deixar a imagem com o efeito negativo você precisa inverter as cores. Isso pode ser feito alterando o valor do pixel para o seu valor contrário. Dessa forma, só precisamos subtrair o valor atual do pixel de 255.</p>
					<p>A linha de código abaixo ilustra isso e o código:</p>
					<p><b>image.at<uchar>(i,j)=255-image.at<uchar>(i,j);</b></p>
					<p><img class="img-responsive" src="assets/img/img1.png" alt=""></p>
					<br>
					<br>
					<h4>Exercício 3.3 - Troca de Regiões</h4>
					<br>
					<p><img class="img-responsive" src="assets/img/img3.png" alt=""></p>
					<br>
					<p>Esse algoritmo divide a imagem em 4 regiões e em seguida as troca de maneira aleatória.</p>
					<p>Primeiramente usamos a função Rect() para recortar 4 retângulos e salvamos as 4 regiões em variáveis, depois criamos um looping para montar a nova imagem com as 4 regiões aleatoriamente como na image acima.</p>
					<p>O código desenvolvido segue abaixo:</p>
					<p><img class="img-responsive" src="assets/img/img4.png" alt=""></p>
					<br>
					<h4>Exercício 4.2.1 - Preenchendo Regiões</h4>
					<p>Utilizando o seedfill ele irá pintar cada objeto encontrado com um tom de cinza. Se a imagem possuir mais de 255 objetos, podemos utiizar outro tipo de variável no lugar de unsigned char, pois a diferença no tom de cinza para nós será impeceptível, mas o computador conseguirá contar a quantidade de objeto.</p>
					<br>
					<h4>Exercício 4.2.2 - Preenchendo Regiões</h4>
					<br>
					<p>Primeiramente limpamos as bordas na imagem, visto que na borda não conseguimos saber se existe buraco ou não.</p>
					<p>Para limpar as bordas varremos a imagem na primeira linha e coluna, além de também varrer a última linha e coluna. Se um objeto for encontrado, aplicamos o seefill mudando o valor do pixel para 0, ou seja, ficando o qual o fundo.</p>
					<p>Resultado da limpeza nas bordas abaixo:</p>
					<p><img class="img-responsive" src="assets/img/img5.png" alt=""></p>
					<p>Em seguida aplicamos o seedfill em toda imagem para o tom de cinza 10. Isso é feito para que o fundo da imagem seja diferenciado dos buracos.</p>
					<p>Para contar quantos buracos tem e diferenciar os objetos com buracos dos sem buracos, varremos a imagem procurando por objetos (pixels com valor 255) e salvamos sua coordenada. Se ele não for 255 verificamos se ele é 0 (buraco), caso seja 0, indica que o último valor branco encontrado é um objeto com buraco, assim, aplicamos o seedfill para um tom 150 no buraco, no objeto e incrementamos um contador.</p>
					<p>Segue esse trecho de código abaixo:</p>
					<p><img class="img-responsive" src="assets/img/img6.png" alt=""></p>
					<br>
					<p>Segue abaixo retorno final do software:</p>
					<p><img class="img-responsive" src="assets/img/img7.png" alt=""></p>
					<br>
					<h4>Exercício 5.2.1 - Histograma</h4>
					<p>Para equalizar a imagem utilizei a função do openCV equalizeHist() e o código de calculo do histograma disponibilizado pelo professor. Além disso, associei a função equalize com outras do openCV.</p>
					<p>O código usado pode ser visto abaixo:</p>
					<br>
					<p><img class="img-responsive" src="assets/img/img8.png" alt=""></p>
					<br>
					<p>A função cvtColor converte a função de RGN para YCrCb que é um sistema com uma componente de luminância é 2 de cores.</p>
					<p>A função split vai separar os canais da imagem sendo 0 o Y a luminância (informação de preto e branco) e 1 e 2 as componentes de cores Cr e Cb respectivamente.</p>
					<p>A função equalizeHist é a que realiza de fato a equalização da nossa imagem, essa equalização é feita no primeiro canal o 0, isso por que é nele que está o Y (quantidade de preto de branco).</p>
					<p>Merge faz o contrário da função split, ele une os canais.</p>
					<p>E a função cvtColor novamente vai converter a imagem, só que dessa vez novamente para o formato RGB</p>
					<h4>Exercício 5.2.2 - Detector de Movimento Usando Histograma</h4>
					<p>Esse exercício ainda não foi realizado, pois não consegui uma webcam.</p>
					<br>
					<h4>Exercícios 6.2 - Filtro Espacial</h4>
					<p>Para calcular o laplaciano do gaussiano só precisamos rodar um filtro e depois o outro.</p>
					<p>Primeiramente adicionei a opção <b>p</b> para o usuário escolher, quando o usuário escolhe essa opção uma váriavel vira true e a função é desencadeada como mostra o código abaixo:</p>
					<br>
					<p><img class="img-responsive" src="assets/img/img9.png" alt=""></p>
					<p>Dentro do if, nós atribuimos para a variável mask o filtro do gassiano, realizamos um ganho nele e depois aplicamos na imagem com a função filter2D, a função filter2D tem como saída a matriz framelapgau que logo em seguida será a entrada da função filter2D, só que dessa vez ela executa o filtro do laplaciano.</p>
					<p>Por fim, a segunda execução do filter2D retorna frameFiltered que é a nossa imagem com o laplaciano do gaussiano.</p>
					<p>A imagem abaixo mostra o resultado da aplicação desse filtro e a comparação com o laplaciano e a original.</p>
					<p><b>Original-Laplaciano</b></p>
					<p><img class="img-responsive" src="assets/img/img10.png" alt=""></p>
					<p><b>Original-Laplaciano do gaussiano</b></p>
					<p><img class="img-responsive" src="assets/img/img11.png" alt=""></p>
					<h4>Exercício 7.1 - Tiltshift</h4>
					<p>Para implementar o efeito utilizamos a função addweighted para fazer a combinação de duas imagens para uma dado coeficiente alfa. Uma imagem será a foto a qual o filtro será aplicado, a outra é a mesma só que borrada através de um filtro da méda e o coeficiente utilizado é uma função que modela a região de desfoque no eixo vertical.</p>
					<p>A função utilizada é a seguinte: α(x)=1/2((tanhx−l1)/d−(tanhx−l2)/d)</p>
					<p>Onde l1 e l2 delimita a área onde a foto terá foco e d é a intensidade com que a área será desfocada</p>
					<p>No algoritmo utilizamos trackbars para escolher a posição que a área de foco estará, o tamanho da área de foco, como também o intensidade do desfoque.</p>
					<p>A implementação da função criada para aplicar o filtro e calcular os área segue abaixo:</p>
					<p><img class="img-responsive" src="assets/img/img12.png" alt=""></p>
					<p>A função on_trackbar_blend é chamada a cada vez que usamos a trackbar, nela calculamos os valores de l1 e l2 utilizando a posição atual das trackbars, em seguida dentro de um looping chamamos a função alfa_calc que realizará o calculo do coeficiente para cada linha da imagem, após o calculo desse coeficiente, a já referida função addweighted aplica o efeito tiltshift para de cada linha da imagem de cada vez.</p>
					<p>Segue abaixo o resultado do efeito:</p>
					<p><img class="img-responsive" src="assets/img/img13.png" alt=""></p>
					
				</div>

			</div><!-- /row -->
	    </div> <!-- /container -->
	</div><!-- /white -->
	
	
	
	
	<!-- +++++ Footer Section +++++ -->
	
	<div id="footer">
		<div class="container">
			<div class="row">
				<div class="col-lg-4">
					<h4>Sobre</h4>
					<p>
						Matheus Vínicius Medeiros de Souza<br/>
						Estudante de Eng. Elétrica - UFRN <br/>
					</p>
				</div><!-- /col-lg-4 -->
				
				<div class="col-lg-4">
					<h4>Contato</h4>
					<p>
						matheus.vinicius2008@gmail.com
					</p>
				</div><!-- /col-lg-4 -->
			</div>
		
		</div>
	</div>
	

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="assets/js/bootstrap.min.js"></script>
  </body>
</html>
